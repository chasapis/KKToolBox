/*******************************************************************
**  Program: pmodel.c
**  Author: Bogdan Hnat for the University of Warwick, Space & Astrophysics
**  Date: 15-Feb-2005
**  Description: This program generates p-model time series
**  with a given p-probability value inputed at run time. Algorithm
**  based on C. Maneveau & K. R. Sreenivasan Phys. Rev. Lett. 59, 1424 (1987)
**  note: n has to be in powers of 2
*********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#define ABSV(a)  ((a)>0 ? (a) : (-a))

static double ran1 (int *idum);
static double ran3 (long *idum);
static double gasdev (int *idum);
static void    cascade(double curd, double* ld, double* rd, double p, double lr);

FILE  *out; 
 
int main (int argc,char *argv[])
{
    int             number, j, i, l, k, n, mid, iter;
    long          idem=-1;
    char          arg[64], outfn[64], *eqptr;
    double     *data, *olddata, h, h1, h2, p, lr, dt, dp, rp;

    if( argc > 1 )
    {
        for(i = 1; i < argc; i++)
	{
	    eqptr = strchr(argv[i], '=');
	    strcpy(arg, eqptr + 1);
	    switch(argv[i][0])
	    {
	       case 'p':
	       case 'P':
                  p = atof(arg);
		  break;
	       case 'n':
	       case 'N':
		  number = atoi(arg);
		  break;
	       case 'h':
	       case 'H':
		  h = atof(arg);
		  break;
	       case 'o':
	       case 'O':
	          strcpy(outfn, arg);
		  break;
	    }
	}
    }
    printf("Input parameters: %f  %d  %f  %s\n", p, number, h, outfn);
    /* We need number to be odd so it easier to devide to 2 */
    if(number%2==0) number++;
    data=(double*)malloc(sizeof(double));
    olddata=(double*)malloc(sizeof(double));
    if( (data==NULL)&&(olddata==NULL) )
    {
          printf("Could not allocate memory!\n");
	  exit(-1); 
    }
    
    /* Estimate number of iteration needed to get number points */
    iter=(int)(log2(number));
   
    if(argc>0) /* enough arguments? */
    {
        olddata[0]=h;
        for(i=1; i<=iter; i++)
	{
	      printf("Iteration %d . ", i);
	      n=(int)pow(2.0, (double)i);
	      mid=n/2; k=0;
	      data=realloc(data, n*sizeof(double));
	      for(j=0; j<mid; j++)
	      {
	            idem=(long)(-ABSV(ran3(&idem)));
		    lr=ran3(&idem); 
		    dp=gasdev((int*)(&idem)); rp=p+(dp/10);
		    cascade(olddata[j], &h1, &h2, rp, lr);
		    /*printf("%.3f %3.3f %3.3f |",rp,h1,h2);*/
		    data[2*j]=h1; data[2*j+1]=h2;
		    if((j>0)&&(j%(10000*mid)==0)) printf(". ");
	      }
	      printf("completed\n");
	      olddata=(double*)realloc(olddata, n*sizeof(double));
	      for(j=0; j<n; j++) olddata[j]=data[j];
	}

	/* Now write this out */
	out = fopen(outfn, "w");
	dt=1/number;
	for(i=0; i <number; i++) fprintf(out,"%f %f\n", (double)i, data[i]);
    }
    fclose(out);
    free(data); free(olddata);
    return (0); /* for lint formalities */

}

static void    cascade(double curd, double* ld, double* rd, double p, double lr)
{
	double   d1, d2; /* random selection of  left/right point */
	/*printf("\nCascade %f %f\n", p, lr); */
	if(lr<=0.5)
	{
	     d1=2*p*curd;
	     d2=2*(1-p)*curd;
	}
        else  
	{
	     d2=2*p*curd;
	     d1=2*(1-p)*curd;
	}
	*ld=d1; *rd=d2;
}

#define M1 259200
#define IA1 7141
#define IC1 54773
#define RM1 (1.0/M1)
#define M2 134456
#define IA2 8121
#define IC2 28411
#define RM2 (1.0/M2)
#define M3 243000
#define IA3 4561
#define IC3 51349

/*

Returns a uniform random deviate between 0.0 and 1.0. Set idum to any
negative value to initialize or reinitialize the sequence. See
"Numerical Recipes in C: The Art of Scientific Computing," William
H. Press, Brian P. Flannery, Saul A. Teukolsky, William T. Vetterling,
Cambridge University Press, New York, 1988, ISBN 0-521-35465-X, page
210, referencing Knuth.

*/

static double ran1 (int *idum)
{
    static int iff = 0;

    static long ix1,
                ix2,
                ix3;

    static double r[98];

    int j;

    double temp;

    if (*idum < 0 || iff == 0) /* initialize on first call even if idum is not negative */
    {
        iff = 1;
        ix1 = (IC1 - (*idum)) % M1; /* seed first routine */
        ix1 = (IA1 * ix1 + IC1) % M1;
        ix2 = ix1 % M2; /* use first to seed second routine */
        ix1 = (IA1 * ix1 +IC1) % M1;
        ix3 = ix1 % M3; /* use first to seed third routine */

        for (j = 1; j <= 97; j++) /* fill table with sequential uniform deviates generated by first two routines */
        {
            ix1 = (IA1 * ix1 + IC1) % M1;
            ix2 = (IA2 * ix2 + IC2) % M2;
            r[j] = (ix1 + ix2 * RM2) * RM1; /* low and high order pieces combined here */
        }

        *idum = 1;
    }

    ix1 = (IA1 * ix1 + IC1) % M1; /* except when initializing, this is the start-generate the next number for each sequence */
    ix2 = (IA2 * ix2 + IC2) % M2;
    ix3 = (IA3 * ix3 + IC3) % M3;
    j = 1 + ((97 * ix3)/M3); /* use the third sequence to get an integer between 1 and 97 */

    if (j > 97 || j < 1)
    {
        (void) fprintf (stderr, "RAN1: This can not happen.\n");
        exit (1);
    }

    temp = r[j]; /* return that table entry */
    r[j] = (ix1 + ix2 * RM2) * RM1; /* refill the table's entry */
    return (temp);
}

#define MBIG 1000000000L
#define MSEED 161803398L
#define MZ 0
#define FAC (1.0/MBIG)

static double ran3 (long *idum)
{
        static int inext,inextp;
        static long ma[56];
        static int iff=0;
        long mj,mk;
        int i,ii,k;

        if (*idum < 0 || iff == 0) {
                iff=1;
                mj=MSEED-(*idum < 0 ? -*idum : *idum);
                mj %= MBIG;
                ma[55]=mj;
                mk=1;
                for (i=1;i<=54;i++) {
                        ii=(21*i) % 55;
                        ma[ii]=mk;
                        mk=mj-mk;
                        if (mk < MZ) mk += MBIG;
                        mj=ma[ii];
                }
                for (k=1;k<=4;k++)
                        for (i=1;i<=55;i++) {
                                ma[i] -= ma[1+(i+30) % 55];
                                if (ma[i] < MZ) ma[i] += MBIG;
                        }
                inext=0;
                inextp=31;
                *idum=1;
        }
        if (++inext == 56) inext=1;
        if (++inextp == 56) inextp=1;
        mj=ma[inext]-ma[inextp];
        if (mj < MZ) mj += MBIG;
        ma[inext]=mj;
        return mj*FAC;
}

#undef MBIG
#undef MSEED
#undef MZ
#undef FAC

/*
Returns a normally distributed deviate with zero mean and unit
variance, using ran1 () as the source of uniform deviates. Set idum to
any negative value to initialize or reinitialize the sequence. See
"Numerical Recipes in C: The Art of Scientific Computing," William
H. Press, Brian P. Flannery, Saul A. Teukolsky, William T. Vetterling,
Cambridge University Press, New York, 1988, ISBN 0-521-35465-X, page
217.

*/

static double gasdev (int *idum)
{
    static int iset = 0;
    static double gset;
    double fac, r, v1, v2;

    if(iset==0)
    {
        do /* no deviate */
        {
            /* get two uniform numbers in the square extending from -1 to +1
               in each direction */
            v1=2.0*ran3(idum)-1.0; 
            v2=2.0*ran3(idum)-1.0;
            r=v1*v1+v2*v2; /* see if they are in the unit circle */
        }
        while (r >= 1.0); /* if not, try again */
        /* make the Box-Muller transformation to get two normal deviates,
           return one, save the other for next call */
        fac=sqrt(-2.0*log(r)/r); 
        gset=v1*fac;
        iset=1; /* set flag */
        return(v2*fac);
    }

    else
    {
        iset=0; /* extra deviat from last time, unset flag, return it */
        return (gset);
    }

}
